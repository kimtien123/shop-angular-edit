{"ast":null,"code":"import { EventEmitter } from \"@angular/core\";\nimport { of, from as fromPromise } from \"rxjs\";\nimport { catchError, tap, map } from \"rxjs/operators\";\nimport { AngularFireDatabase } from \"@angular/fire/compat/database\";\nimport { MessageService } from \"../../../messages/message.service\";\nimport { AuthService } from \"../../shared/auth.service\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../messages/message.service\";\nimport * as i2 from \"../../shared/auth.service\";\nimport * as i3 from \"@angular/fire/compat/database\";\nexport let CategoryService = /*#__PURE__*/(() => {\n  class CategoryService {\n    constructor(messageService, authService, store, angularFireDatabase) {\n      this.messageService = messageService;\n      this.authService = authService;\n      this.store = store;\n      this.angularFireDatabase = angularFireDatabase;\n      this.orderSelected = new EventEmitter();\n    }\n\n    log(message) {\n      this.messageService.add(\"CategoryService: \" + message);\n    }\n\n    getCategories() {\n      return this.angularFireDatabase.list('/categories', ref => ref.orderByChild('date')).valueChanges().pipe(map(arr => arr.reverse()), catchError(this.handleError(`getCategories`)));\n    }\n\n    addCategory(category) {\n      console.log('categorycategory', category);\n      const databaseOperation = this.store.list(`/categories`).push(category).then(response => response, error => error);\n      return fromPromise(databaseOperation);\n    }\n\n    updateCategory(category) {\n      const url = `${'/categories'}/${category.id}`;\n      return fromPromise(this.store.object(url).update(category).then(response => response, error => error));\n    }\n\n    getCategory(id) {\n      const url = `${'/categories'}/${id}`;\n      console.log('urlurl', url);\n      return this.angularFireDatabase.object(url).valueChanges().pipe(tap(result => {\n        if (result) {\n          return of(result);\n        } else {\n          this.messageService.addError(`Found no Product with id=${id}`);\n          return of(null);\n        }\n      }), catchError(this.handleError(`getProduct id=${id}`)));\n    }\n\n    deleteCategory(category) {\n      const url = `${'/categories'}/${category.id}`;\n      return this.angularFireDatabase.object(url).remove().then(() => this.log('success deleting' + category.name)).catch(error => {\n        this.messageService.addError('Delete failed ' + category.name);\n        this.handleError('delete product');\n      });\n    }\n\n    handleError(operation = \"operation\", result) {\n      return error => {\n        // TODO: send the error to remote logging infrastructure\n        console.error(error); // log to console instead\n        // TODO: better job of transforming error for user consumption\n\n        this.messageService.addError(`${operation} failed: ${error.message}`); // Let the app keep running by returning an empty result.\n\n        return of(result);\n      };\n    }\n\n    updateStatusOrder(index, newStatus) {\n      return this.store.list('/orders', ref => ref.orderByChild('numberOrder').equalTo(index)).snapshotChanges().subscribe(actions => {\n        actions.forEach(action => {\n          // here you get the key\n          console.log(action.key);\n          this.store.list('/orders').update(action.key, {\n            status: newStatus\n          });\n        });\n      });\n    }\n\n  }\n\n  CategoryService.ɵfac = function CategoryService_Factory(t) {\n    return new (t || CategoryService)(i0.ɵɵinject(i1.MessageService), i0.ɵɵinject(i2.AuthService), i0.ɵɵinject(i3.AngularFireDatabase), i0.ɵɵinject(i3.AngularFireDatabase));\n  };\n\n  CategoryService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CategoryService,\n    factory: CategoryService.ɵfac,\n    providedIn: \"root\"\n  });\n  return CategoryService;\n})();","map":null,"metadata":{},"sourceType":"module"}